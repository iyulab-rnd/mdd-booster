using MDDBooster.Models;

namespace MDDBooster.Builders.MsSql;

/// <summary>
/// Generator for SQL Server schema and table definitions
/// </summary>
public class MsSqlSchemaGenerator
{
    private readonly MDDDocument _document;
    private readonly bool _useSchemaNamespace;
    private readonly string _schemaNameOverride;

    public MsSqlSchemaGenerator(MDDDocument document, bool useSchemaNamespace = true, string schemaNameOverride = "dbo")
    {
        _document = document ?? throw new ArgumentNullException(nameof(document));
        _useSchemaNamespace = useSchemaNamespace;
        _schemaNameOverride = schemaNameOverride;
        AppLog.Debug("MsSqlSchemaGenerator initialized for namespace: {Namespace}", _document.BaseDocument.Namespace);
    }

    /// <summary>
    /// Generate complete schema SQL including all tables, constraints, and indexes
    /// </summary>
    public string GenerateSchema()
    {
        AppLog.Information("Generating schema for namespace: {Namespace}", _document.BaseDocument.Namespace);
        var sb = new StringBuilder();

        // Add header comment
        sb.AppendLine("-- # Code generated by \"MDD Booster\"; DO NOT EDIT.");
        sb.AppendLine();

        // Add schema creation (if namespace is defined and we're using schema namespaces)
        var schemaName = _useSchemaNamespace ? _document.BaseDocument.Namespace : _schemaNameOverride;
        if (_useSchemaNamespace && !string.IsNullOrEmpty(schemaName))
        {
            sb.AppendLine($"-- Create schema if not exists");
            sb.AppendLine($"IF NOT EXISTS (SELECT * FROM sys.schemas WHERE name = '{schemaName}')");
            sb.AppendLine($"BEGIN");
            sb.AppendLine($"    EXEC('CREATE SCHEMA [{schemaName}]')");
            sb.AppendLine($"END");
            sb.AppendLine($"GO");
            sb.AppendLine();
        }

        // Get only non-abstract models
        var nonAbstractModels = _document.Models.Where(m => !m.BaseModel.IsAbstract).ToList();

        // Generate tables for each model
        foreach (var model in nonAbstractModels)
        {
            AppLog.Debug("Generating table definition for model: {ModelName}", model.BaseModel.Name);
            sb.Append(GenerateTable(model));
            sb.AppendLine();
        }

        // Generate indexes
        foreach (var model in nonAbstractModels)
        {
            var indexes = GenerateIndexes(model);
            if (!string.IsNullOrEmpty(indexes))
            {
                AppLog.Debug("Generating indexes for model: {ModelName}", model.BaseModel.Name);
                sb.Append(indexes);
                sb.AppendLine();
            }
        }

        AppLog.Information("Schema generation completed for {Count} tables", nonAbstractModels.Count);
        return sb.ToString();
    }

    /// <summary>
    /// Convert a name to PascalCase
    /// </summary>
    private string ToPascalCase(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        // Split by underscores
        var parts = name.Split('_');
        for (int i = 0; i < parts.Length; i++)
        {
            if (!string.IsNullOrEmpty(parts[i]))
            {
                parts[i] = char.ToUpperInvariant(parts[i][0]) + parts[i].Substring(1);
            }
        }

        return string.Join("", parts);
    }

    /// <summary>
    /// Generate SQL for a single table
    /// </summary>
    private string GenerateTable(MDDModel model)
    {
        var sb = new StringBuilder();
        var tableName = ToPascalCase(model.BaseModel.Name);
        var schemaName = _useSchemaNamespace ? _document.BaseDocument.Namespace : _schemaNameOverride;

        // Start CREATE TABLE statement
        sb.AppendLine($"CREATE TABLE [{schemaName}].[{tableName}]");
        sb.AppendLine("(");

        // Get all fields including inherited ones
        var allFields = GetAllFields(model);

        // Generate column definitions
        var columnDefs = new List<string>();
        var uniqueConstraints = new List<string>();

        foreach (var field in allFields)
        {
            // Skip fields marked for exclusion
            if (field.ShouldExcludeFromSql())
            {
                continue;
            }

            // Skip fields that are actually index definitions
            if (IsIndexDefinition(field))
            {
                continue;
            }

            try
            {
                // Get field properties with proper casing
                var fieldName = ToPascalCase(field.BaseField.Name);
                var sqlType = GetSqlType(field);
                var nullableStr = field.BaseField.IsNullable ? "NULL" : "NOT NULL";
                var defaultStr = !string.IsNullOrEmpty(field.BaseField.DefaultValue)
                    ? $" DEFAULT {TransformDefaultValue(field.BaseField.DefaultValue, field.BaseField.Type)}"
                    : "";

                if (field.BaseField.IsPrimaryKey)
                {
                    // Special handling for GUIDs as primary keys
                    if (field.BaseField.Type.ToLowerInvariant() == "identifier" ||
                        sqlType.Contains("UNIQUEIDENTIFIER"))
                    {
                        columnDefs.Add($"    [{fieldName}] {sqlType} NOT NULL PRIMARY KEY DEFAULT NEWID()");
                    }
                    else
                    {
                        columnDefs.Add($"    [{fieldName}] {sqlType} {nullableStr} PRIMARY KEY{defaultStr}");
                    }
                }
                else
                {
                    columnDefs.Add($"    [{fieldName}] {sqlType} {nullableStr}{defaultStr}");
                }

                // Check if field has unique constraint
                if (field.BaseField.IsUnique)
                {
                    uniqueConstraints.Add($"    CONSTRAINT [UK_{tableName}_{fieldName}] UNIQUE NONCLUSTERED ([{fieldName}])");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"ERROR processing field '{field.BaseField?.Name ?? "unknown"}': {ex.Message}");
                // Skip this field but continue processing others
                continue;
            }
        }

        // Add primary key constraint if not already specified on a field
        if (!allFields.Any(f => f.BaseField.IsPrimaryKey))
        {
            columnDefs.Add($"    [_id] UNIQUEIDENTIFIER NOT NULL PRIMARY KEY DEFAULT NEWID()");
        }

        // Add all column definitions first, then constraints
        sb.AppendLine(string.Join(",\n", columnDefs));

        // Add unique constraints if any
        if (uniqueConstraints.Any())
        {
            sb.AppendLine(",");
            sb.AppendLine(string.Join(",\n", uniqueConstraints));
        }

        sb.AppendLine(")");
        sb.AppendLine("GO");

        return sb.ToString();
    }

    /// <summary>
    /// Generate index SQL for a table
    /// </summary>
    private string GenerateIndexes(MDDModel model)
    {
        var sb = new StringBuilder();
        var tableName = ToPascalCase(model.BaseModel.Name);
        var schemaName = _useSchemaNamespace ? _document.BaseDocument.Namespace : _schemaNameOverride;

        // Get indexes from model
        var indexes = model.BaseModel.Indexes;
        if (indexes == null || !indexes.Any())
        {
            return string.Empty;
        }

        foreach (var index in indexes)
        {
            if (index.Fields == null || !index.Fields.Any())
            {
                continue;
            }

            var indexType = index.IsUnique ? "UNIQUE" : "";

            // Generate proper index name
            var indexName = index.Name;
            if (string.IsNullOrEmpty(indexName))
            {
                var prefix = index.IsUnique ? "UK" : "IX";
                indexName = $"{prefix}_{tableName}_{string.Join("_", index.Fields.Select(ToPascalCase))}";
            }

            sb.AppendLine($"CREATE {indexType} INDEX [{indexName}] ON [{schemaName}].[{tableName}]");
            sb.AppendLine("(");

            var fieldDefs = new List<string>();
            foreach (var field in index.Fields)
            {
                fieldDefs.Add($"    [{ToPascalCase(field)}] ASC");
            }

            sb.AppendLine(string.Join(",\n", fieldDefs));
            sb.AppendLine(")");
            sb.AppendLine("GO");
        }

        return sb.ToString();
    }

    private bool IsIndexDefinition(MDDField field)
    {
        if (field == null || field.BaseField == null || field.BaseField.Name == null)
        {
            return false;
        }

        // Check if the field name starts with '@index' or '@unique'
        return field.BaseField.Name.StartsWith("@index") ||
               field.BaseField.Name.StartsWith("@unique");
    }

    /// <summary>
    /// Get SQL type for a field with appropriate size limits
    /// </summary>
    private string GetSqlType(MDDField field)
    {
        string sqlType;

        switch (field.BaseField.Type.ToLowerInvariant())
        {
            case "identifier":
                sqlType = "UNIQUEIDENTIFIER";
                break;
            case "string":
                var length = string.IsNullOrEmpty(field.BaseField.Length) ? "50" : field.BaseField.Length;
                sqlType = $"NVARCHAR({length})";
                break;
            case "text":
                sqlType = "NVARCHAR(MAX)";
                break;
            case "integer":
                sqlType = "INT";
                break;
            case "decimal":
                var precision = "18,2"; // default
                if (!string.IsNullOrEmpty(field.BaseField.Length))
                {
                    precision = field.BaseField.Length;
                }
                sqlType = $"DECIMAL({precision})";
                break;
            case "boolean":
                sqlType = "BIT";
                break;
            case "timestamp":
            case "datetime":
                sqlType = "DATETIME2";
                break;
            case "date":
                sqlType = "DATE";
                break;
            case "enum":
                // For enums, we'll use INT
                sqlType = "INT";
                break;
            default:
                // Handle unknown types as NVARCHAR(50)
                sqlType = "NVARCHAR(50)";
                break;
        }

        return sqlType;
    }

    /// <summary>
    /// Transform default value for SQL Server
    /// </summary>
    private string TransformDefaultValue(string defaultValue, string type)
    {
        // Handle special default values
        if (defaultValue == "now()")
        {
            return "GETDATE()";
        }
        else if (defaultValue == "true")
        {
            return "1";
        }
        else if (defaultValue == "false")
        {
            return "0";
        }
        else if (defaultValue.StartsWith("\"") && defaultValue.EndsWith("\""))
        {
            // String literal
            return $"N{defaultValue}";
        }
        else if (defaultValue == "@now")
        {
            return "GETDATE()";
        }
        else if (defaultValue == "@by")
        {
            return "N'@system'";
        }

        // Default handling
        switch (type.ToLowerInvariant())
        {
            case "string":
            case "text":
                return $"N'{defaultValue}'";
            default:
                return defaultValue;
        }
    }

    /// <summary>
    /// Get all fields for a model, including from inherited models and interfaces
    /// </summary>
    private List<MDDField> GetAllFields(MDDModel model)
    {
        var fields = new List<MDDField>(model.Fields);

        // Add fields from inherited models and interfaces
        foreach (var inheritedTypeName in model.BaseModel.Inherits)
        {
            var inheritedModel = _document.Models.FirstOrDefault(m => m.BaseModel.Name == inheritedTypeName);
            if (inheritedModel != null)
            {
                fields.AddRange(GetAllFields(inheritedModel));
                continue;
            }

            var inheritedInterface = _document.Interfaces.FirstOrDefault(i => i.BaseInterface.Name == inheritedTypeName);
            if (inheritedInterface != null)
            {
                fields.AddRange(inheritedInterface.Fields);
            }
            else
            {
                Console.WriteLine($"WARNING: Inherited type '{inheritedTypeName}' not found as model or interface");
            }
        }

        return fields;
    }
}