namespace MDDBooster.Builders.MsSql;

/// <summary>
/// Generates complete SQL scripts for a given MDDDocument
/// </summary>
public class MsSqlScriptGenerator
{
    private readonly MDDDocument _document;
    private readonly MsSqlSchemaGenerator _schemaGenerator;
    private readonly MsSqlTriggerGenerator _triggerGenerator;

    public MsSqlScriptGenerator(MDDDocument document, bool useSchemaNamespace = true, string schemaNameOverride = "dbo")
    {
        _document = document;
        _schemaGenerator = new MsSqlSchemaGenerator(document, useSchemaNamespace, schemaNameOverride);
        _triggerGenerator = new MsSqlTriggerGenerator(document);
        AppLog.Debug("MsSqlScriptGenerator initialized for namespace: {Namespace}", _document.BaseDocument.Namespace);
    }

    /// <summary>
    /// Generates a complete SQL script including schema, tables, indexes, and triggers
    /// </summary>
    public string GenerateCompleteScript()
    {
        AppLog.Information("Generating complete SQL script for namespace: {Namespace}", _document.BaseDocument.Namespace);

        var sb = new StringBuilder();

        // Add header
        sb.AppendLine("-- SQL Server Script generated by MDDBooster");
        sb.AppendLine($"-- Generated on: {DateTime.Now}");
        sb.AppendLine($"-- Namespace: {_document.BaseDocument.Namespace}");
        sb.AppendLine();

        // Add schema and tables
        AppLog.Debug("Adding schema and tables section to script");
        sb.AppendLine("-- Schema and Tables");
        sb.AppendLine("-- =================");
        sb.AppendLine();
        sb.Append(_schemaGenerator.GenerateSchema());

        // Add triggers
        AppLog.Debug("Adding triggers section to script");
        sb.AppendLine("-- Triggers");
        sb.AppendLine("-- ========");
        sb.AppendLine();
        sb.Append(_triggerGenerator.GenerateTriggers());

        AppLog.Information("Complete SQL script generation finished");
        return sb.ToString();
    }

    /// <summary>
    /// Generates SQL scripts for specific functions
    /// </summary>
    public Dictionary<string, string> GenerateScripts()
    {
        AppLog.Information("Generating separate SQL scripts for namespace: {Namespace}", _document.BaseDocument.Namespace);

        var scripts = new Dictionary<string, string>();

        // Schema and tables
        AppLog.Debug("Generating schema script");
        scripts["schema"] = _schemaGenerator.GenerateSchema();

        // Triggers
        AppLog.Debug("Generating triggers script");
        scripts["triggers"] = _triggerGenerator.GenerateTriggers();

        // Complete script
        AppLog.Debug("Generating complete script");
        scripts["complete"] = GenerateCompleteScript();

        AppLog.Information("Generated {Count} separate SQL scripts", scripts.Count);
        return scripts;
    }

    /// <summary>
    /// Generates migration scripts between two versions of a model
    /// </summary>
    public string GenerateMigrationScript(MDDDocument oldDocument, MDDDocument newDocument)
    {
        AppLog.Information("Generating migration script from {OldNamespace} to {NewNamespace}",
            oldDocument.BaseDocument.Namespace, newDocument.BaseDocument.Namespace);

        var sb = new StringBuilder();

        // Add header
        sb.AppendLine("-- SQL Server Migration Script generated by MDDBooster");
        sb.AppendLine($"-- Generated on: {DateTime.Now}");
        sb.AppendLine($"-- From namespace: {oldDocument.BaseDocument.Namespace}");
        sb.AppendLine($"-- To namespace: {newDocument.BaseDocument.Namespace}");
        sb.AppendLine();

        // Start transaction
        sb.AppendLine("BEGIN TRANSACTION;");
        sb.AppendLine("GO");
        sb.AppendLine();

        // Find new models
        var oldModelNames = oldDocument.Models.Select(m => m.BaseModel.Name).ToHashSet();
        var newModels = newDocument.Models.Where(m => !m.BaseModel.IsAbstract && !oldModelNames.Contains(m.BaseModel.Name)).ToList();

        if (newModels.Any())
        {
            AppLog.Debug("Found {Count} new models to create", newModels.Count);
            sb.AppendLine("-- New tables to create");
            sb.AppendLine("-- ===================");
            sb.AppendLine();

            // Create new schema builder to generate just the new tables
            var tempDoc = new MDDDocument
            {
                BaseDocument = newDocument.BaseDocument,
                Models = newModels,
                Interfaces = newDocument.Interfaces,
                Enums = newDocument.Enums
            };

            var schemaGenerator = new MsSqlSchemaGenerator(tempDoc);
            sb.Append(schemaGenerator.GenerateSchema());
        }
        else
        {
            AppLog.Debug("No new models to create");
        }

        // Find new fields in existing models
        var existingModelNames = oldDocument.Models.Where(m => !m.BaseModel.IsAbstract)
            .Select(m => m.BaseModel.Name).ToHashSet();

        var existingModelsWithChanges = newDocument.Models
            .Where(m => !m.BaseModel.IsAbstract && existingModelNames.Contains(m.BaseModel.Name))
            .ToList();

        AppLog.Debug("Checking {Count} existing models for field changes", existingModelsWithChanges.Count);

        foreach (var newModel in existingModelsWithChanges)
        {
            var oldModel = oldDocument.Models.First(m => m.BaseModel.Name == newModel.BaseModel.Name);

            // Find new fields
            var oldFieldNames = oldModel.Fields.Select(f => f.BaseField.Name).ToHashSet();
            var newFields = newModel.Fields.Where(f => !oldFieldNames.Contains(f.BaseField.Name)).ToList();

            if (newFields.Any())
            {
                AppLog.Debug("Found {Count} new fields in model {ModelName}", newFields.Count, newModel.BaseModel.Name);
                sb.AppendLine($"-- New fields for table {newModel.BaseModel.Name}");
                sb.AppendLine($"-- {new string('=', 20 + newModel.BaseModel.Name.Length)}");
                sb.AppendLine();

                foreach (var field in newFields)
                {
                    var sqlType = GetSqlType(field);
                    var nullableStr = field.BaseField.IsNullable ? "NULL" : "NOT NULL";
                    var defaultStr = !string.IsNullOrEmpty(field.BaseField.DefaultValue)
                        ? $" DEFAULT {TransformDefaultValue(field.BaseField.DefaultValue, field.BaseField.Type)}"
                        : "";

                    AppLog.Debug("Adding ALTER TABLE statement for new field {FieldName} in {ModelName}",
                        field.BaseField.Name, newModel.BaseModel.Name);

                    sb.AppendLine($"ALTER TABLE [{newDocument.BaseDocument.Namespace}].[{newModel.BaseModel.Name}] ADD");
                    sb.AppendLine($"    [{field.BaseField.Name}] {sqlType} {nullableStr}{defaultStr};");
                    sb.AppendLine("GO");
                    sb.AppendLine();
                }
            }

            // Find changed fields
            var commonFields = newModel.Fields
                .Where(nf => oldFieldNames.Contains(nf.BaseField.Name))
                .ToList();

            AppLog.Debug("Checking {Count} common fields in model {ModelName} for changes",
                commonFields.Count, newModel.BaseModel.Name);

            foreach (var newField in commonFields)
            {
                var oldField = oldModel.Fields.First(f => f.BaseField.Name == newField.BaseField.Name);

                // Check for type changes
                if (newField.BaseField.Type != oldField.BaseField.Type ||
                    newField.BaseField.Length != oldField.BaseField.Length ||
                    newField.BaseField.IsNullable != oldField.BaseField.IsNullable)
                {
                    var sqlType = GetSqlType(newField);
                    var nullableStr = newField.BaseField.IsNullable ? "NULL" : "NOT NULL";

                    AppLog.Debug("Found changed field {FieldName} in model {ModelName}",
                        newField.BaseField.Name, newModel.BaseModel.Name);

                    sb.AppendLine($"-- Alter field {newField.BaseField.Name} in table {newModel.BaseModel.Name}");
                    sb.AppendLine($"ALTER TABLE [{newDocument.BaseDocument.Namespace}].[{newModel.BaseModel.Name}] ALTER COLUMN");
                    sb.AppendLine($"    [{newField.BaseField.Name}] {sqlType} {nullableStr};");
                    sb.AppendLine("GO");
                    sb.AppendLine();
                }
            }
        }

        // Commit transaction
        sb.AppendLine("COMMIT TRANSACTION;");
        sb.AppendLine("GO");

        AppLog.Information("Migration script generation completed");
        return sb.ToString();
    }

    /// <summary>
    /// Get SQL type for a field
    /// </summary>
    private string GetSqlType(MDDField field)
    {
        if (field == null)
        {
            throw new ArgumentNullException(nameof(field), "Field cannot be null");
        }

        if (field.BaseField == null)
        {
            throw new InvalidOperationException("Field.BaseField cannot be null");
        }

        if (string.IsNullOrEmpty(field.BaseField.Name))
        {
            throw new InvalidOperationException("Field.BaseField.Name cannot be null or empty");
        }

        if (string.IsNullOrEmpty(field.BaseField.Type))
        {
            throw new InvalidOperationException($"Field '{field.BaseField.Name}' has null or empty Type");
        }

        string sqlType;

        switch (field.BaseField.Type.ToLowerInvariant())
        {
            case "identifier":
                sqlType = "UNIQUEIDENTIFIER";
                break;
            case "string":
                var length = string.IsNullOrEmpty(field.BaseField.Length) ? "MAX" : field.BaseField.Length;
                sqlType = $"NVARCHAR({length})";
                break;
            case "text":
                sqlType = "NVARCHAR(MAX)";
                break;
            case "integer":
                sqlType = "INT";
                break;
            case "decimal":
                var precision = "18,2"; // default
                if (!string.IsNullOrEmpty(field.BaseField.Length))
                {
                    precision = field.BaseField.Length;
                }
                sqlType = $"DECIMAL({precision})";
                break;
            case "boolean":
                sqlType = "BIT";
                break;
            case "timestamp":
            case "datetime":
                sqlType = "DATETIME2";
                break;
            case "date":
                sqlType = "DATE";
                break;
            case "enum":
                // For enums, we'll use INT or NVARCHAR based on the implementation
                sqlType = "INT";
                break;
            default:
                // Handle unknown types as NVARCHAR
                Console.WriteLine($"WARNING: Unknown field type: {field.BaseField.Type} for field: {field.BaseField.Name}");
                sqlType = "NVARCHAR(MAX)";
                break;
        }

        return sqlType;
    }

    private string TransformDefaultValue(string defaultValue, string type)
    {
        // Handle special default values
        if (defaultValue == "now()")
        {
            return "GETDATE()";
        }
        else if (defaultValue == "true")
        {
            return "1";
        }
        else if (defaultValue == "false")
        {
            return "0";
        }
        else if (defaultValue.StartsWith("\"") && defaultValue.EndsWith("\""))
        {
            // String literal
            return $"N{defaultValue}";
        }
        else if (defaultValue == "@now")
        {
            return "GETDATE()";
        }
        else if (defaultValue == "@by")
        {
            return "N'system'";
        }

        // Default handling
        switch (type.ToLowerInvariant())
        {
            case "string":
            case "text":
                return $"N'{defaultValue}'";
            default:
                return defaultValue;
        }
    }
}