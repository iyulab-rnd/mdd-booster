using M3LParser.Helpers;
using MDDBooster.Builders.ModelProject.Utilities;
using MDDBooster.Models;
using MDDBooster.Utilities;
using System.Text;

using System.ComponentModel.DataAnnotations.Schema;

namespace MDDBooster.Builders.ModelProject;

/// <summary>
/// Generator for C# model classes
/// </summary>
public class ModelGenerator
{
    public MDDDocument Document { get; }
    private readonly ModelProjectConfig _config;
    private readonly Dictionary<string, List<RelationInfo>> _modelRelations;
    private readonly ModelTypeConverter _typeConverter;
    private readonly ModelAttributeGenerator _attributeGenerator;

    /// <summary>
    /// Represents a relationship between models
    /// </summary>
    private class RelationInfo
    {
        public string SourceModel { get; set; }
        public string TargetModel { get; set; }
        public string PropertyName { get; set; }
        public bool IsToMany { get; set; }
        public string NavigationField { get; set; }
        public bool IsForeignKey { get; set; }
    }

    public ModelGenerator(MDDDocument document, ModelProjectConfig config)
    {
        Document = document;
        _config = config;
        _typeConverter = new ModelTypeConverter(document, config);
        _attributeGenerator = new ModelAttributeGenerator(_typeConverter, config);
        _modelRelations = BuildRelationshipMap();
    }

    /// <summary>
    /// Generate a C# model class for a model
    /// </summary>
    public string GenerateModelClass(MDDModel model)
    {
        return ErrorHandling.ExecuteSafely(() =>
        {
            var sb = new StringBuilder();

            // Add file header
            sb.AppendLine("// Code generated by \"MDD Booster\"; DO NOT EDIT.");
            sb.AppendLine($"namespace {GetNamespace(model)};");
            sb.AppendLine(); // space

            // Add summary comment if description exists
            if (!string.IsNullOrEmpty(model.BaseModel.Description))
            {
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// {model.BaseModel.Description}");
                sb.AppendLine("/// </summary>");
            }

            // Add Table attribute for Entity Framework
            string tableName = StringHelper.NormalizeName(model.BaseModel.Name);
            sb.AppendLine($"[Table(name: \"{tableName}\")]");

            // Class declaration with abstract modifier if needed
            string classModifiers = model.BaseModel.IsAbstract ? "public abstract partial class" :
                                  (_config.UsePartialClasses ? "public partial class" : "public class");
            string className = model.BaseModel.Name;

            // Generate inheritance list
            var inheritance = new List<string>();

            // Add base class first if any
            var baseClass = model.BaseModel.Inherits
                .FirstOrDefault(i => Document.Models.Any(m => m.BaseModel.Name == i));

            if (baseClass != null)
            {
                inheritance.Add(baseClass);
            }

            // Add interfaces
            var interfaces = model.BaseModel.Inherits
                .Where(i => Document.Interfaces.Any(iface => iface.BaseInterface.Name == i))
                .ToList();

            inheritance.AddRange(interfaces);

            string inheritanceString = inheritance.Any()
                ? " : " + string.Join(", ", inheritance)
                : "";

            sb.AppendLine($"{classModifiers} {className}{inheritanceString}");
            sb.AppendLine("{");

            // Add properties from current model (directly declared, not inherited)
            AppendProperties(sb, model);

            // Add navigation properties if configured
            if (_config.GenerateNavigationProperties)
            {
                AppendNavigationProperties(sb, model);
            }

            sb.AppendLine("}");
            return sb.ToString();
        },
        string.Empty,
        "Failed to generate model class for {ModelName}",
        model.BaseModel.Name);
    }

    /// <summary>
    /// Generate a C# interface
    /// </summary>
    public string GenerateInterface(MDDInterface iface)
    {
        return ErrorHandling.ExecuteSafely(() =>
        {
            var sb = new StringBuilder();

            // Add file header
            sb.AppendLine("// Code generated by \"MDD Booster\"; DO NOT EDIT.");
            sb.AppendLine($"namespace {GetNamespace(iface)};");
            sb.AppendLine();

            // Add summary comment if description exists
            if (!string.IsNullOrEmpty(iface.BaseInterface.Description))
            {
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// {iface.BaseInterface.Description}");
                sb.AppendLine("/// </summary>");
            }

            // Interface declaration with inheritance if any
            string inheritance = "";
            if (iface.BaseInterface.Inherits.Any())
            {
                inheritance = " : " + string.Join(", ", iface.BaseInterface.Inherits);
            }

            sb.AppendLine($"public interface {iface.BaseInterface.Name}{inheritance}");
            sb.AppendLine("{");

            // Add properties directly declared in this interface (not inherited)
            var directFields = iface.Fields.Where(f =>
                iface.BaseInterface.Fields.Any(bf => bf.Name == f.BaseField.Name)).ToList();

            foreach (var field in directFields)
            {
                AppendInterfaceProperty(sb, field);
            }

            sb.AppendLine("}");
            return sb.ToString();
        },
        string.Empty,
        "Failed to generate interface for {InterfaceName}",
        iface.BaseInterface.Name);
    }

    /// <summary>
    /// Generate a C# enum
    /// </summary>
    public string GenerateEnum(MDDEnum enum_)
    {
        return ErrorHandling.ExecuteSafely(() =>
        {
            var sb = new StringBuilder();

            // Add file header
            sb.AppendLine("// Code generated by \"MDD Booster\"; DO NOT EDIT.");
            sb.AppendLine($"namespace {GetNamespace(enum_)};");
            sb.AppendLine();

            // Add summary comment if description exists
            if (!string.IsNullOrEmpty(enum_.BaseEnum.Description))
            {
                sb.AppendLine("/// <summary>");
                sb.AppendLine($"/// {enum_.BaseEnum.Description}");
                sb.AppendLine("/// </summary>");
            }

            // Enum declaration
            sb.AppendLine($"public enum {enum_.BaseEnum.Name}");
            sb.AppendLine("{");

            // Add enum values
            for (int i = 0; i < enum_.BaseEnum.Values.Count; i++)
            {
                var value = enum_.BaseEnum.Values[i];

                // Add summary if available
                if (!string.IsNullOrEmpty(value.Description))
                {
                    sb.AppendLine("    /// <summary>");
                    sb.AppendLine($"    /// {value.Description}");
                    sb.AppendLine("    /// </summary>");
                }

                string enumValue = string.IsNullOrEmpty(value.Value)
                    ? ""
                    : $" = {value.Value}";

                // Add comma for all except the last item
                string comma = i < enum_.BaseEnum.Values.Count - 1 ? "," : "";

                sb.AppendLine($"    {value.Name}{enumValue}{comma}");
            }

            sb.AppendLine("}");
            return sb.ToString();
        },
        string.Empty,
        "Failed to generate enum for {EnumName}",
        enum_.BaseEnum.Name);
    }

    /// <summary>
    /// Append properties to a model class
    /// </summary>
    private void AppendProperties(StringBuilder sb, MDDModel model)
    {
        // Get all fields for this model, including those from interfaces it implements
        var allFields = ModelUtilities.GetAllFields(Document, model);

        // Get all fields that would be inherited from base classes
        var inheritedFieldNames = new HashSet<string>();

        foreach (var inheritedClassName in model.BaseModel.Inherits)
        {
            // Skip interfaces, only look at actual classes
            if (Document.Interfaces.Any(i => i.BaseInterface.Name == inheritedClassName))
                continue;

            var baseClassModel = Document.Models.FirstOrDefault(m => m.BaseModel.Name == inheritedClassName);
            if (baseClassModel != null)
            {
                // Get all fields from this base class (recursively)
                var baseClassFields = ModelUtilities.GetAllFields(Document, baseClassModel);
                foreach (var field in baseClassFields)
                {
                    inheritedFieldNames.Add(field.BaseField.Name);
                }
            }
        }

        // Process each field
        foreach (var field in allFields)
        {
            // Skip fields that are already inherited from base classes
            if (inheritedFieldNames.Contains(field.BaseField.Name))
            {
                continue;
            }

            // Skip fields that are not directly declared in this model and not from implemented interfaces
            bool isDeclaredInModel = model.BaseModel.Fields.Any(f => f.Name == field.BaseField.Name);
            bool isFromInterface = model.BaseModel.Inherits.Any(i =>
                Document.Interfaces.Any(iface => iface.BaseInterface.Name == i &&
                                              iface.Fields.Any(f => f.BaseField.Name == field.BaseField.Name)));

            if (!isDeclaredInModel && !isFromInterface)
            {
                continue;
            }

            // Add property annotations
            sb.Append(_attributeGenerator.GeneratePropertyAnnotations(field));

            // Add property definition
            string propertyType = _typeConverter.GetCSharpType(field);
            string propertyName = StringHelper.NormalizeName(field.BaseField.Name);

            // Handle required flag for non-nullable reference types
            string required = (field.BaseField.IsRequired && !field.BaseField.IsNullable &&
                              _typeConverter.IsReferenceType(field.BaseField.Type) && _config.UseNullableReferenceTypes)
                ? "required "
                : "";

            // Basic property implementation
            sb.AppendLine($"\tpublic {required}{propertyType} {propertyName} {{ get; set; }}");
            sb.AppendLine();
        }
    }

    /// <summary>
    /// Append navigation properties to a model class
    /// </summary>
    private void AppendNavigationProperties(StringBuilder sb, MDDModel model)
    {
        // Find all navigation properties for this model
        if (_modelRelations.TryGetValue(model.BaseModel.Name, out var relations))
        {
            foreach (var relation in relations)
            {
                // Skip if we already have a property with this name
                if (model.Fields.Any(f => f.BaseField.Name == relation.PropertyName))
                    continue;

                // Determine property type (collection or single reference)
                string propertyType = relation.IsToMany
                    ? $"ICollection<{relation.TargetModel}>"
                    : relation.TargetModel;

                // Add nullable marker if using nullable reference types
                string nullableMarker = _config.UseNullableReferenceTypes ? "?" : "";

                // Add ForeignKey attribute for single references (N side of 1:N) if we know the foreign key field
                if (!relation.IsToMany && !string.IsNullOrEmpty(relation.NavigationField))
                {
                    sb.AppendLine($"\t[ForeignKey(nameof({relation.NavigationField}))]");
                }

                // Add property with virtual for EF lazy loading
                sb.AppendLine($"\tpublic virtual {propertyType}{nullableMarker} {relation.PropertyName} {{ get; set; }}");
                sb.AppendLine();
            }
        }
    }

    /// <summary>
    /// Append a property to an interface
    /// </summary>
    private void AppendInterfaceProperty(StringBuilder sb, MDDField field)
    {
        string propertyType = _typeConverter.GetCSharpType(field);
        string propertyName = StringHelper.NormalizeName(field.BaseField.Name);

        // Add summary if available
        if (!string.IsNullOrEmpty(field.BaseField.Description))
        {
            sb.AppendLine("\t/// <summary>");
            sb.AppendLine($"\t/// {field.BaseField.Description}");
            sb.AppendLine("\t/// </summary>");
        }

        // Interface property (get and set accessors)
        sb.AppendLine($"\t{propertyType} {propertyName} {{ get; set; }}");
        sb.AppendLine();
    }

    /// <summary>
    /// Build a map of model relationships
    /// </summary>
    private Dictionary<string, List<RelationInfo>> BuildRelationshipMap()
    {
        var relationMap = new Dictionary<string, List<RelationInfo>>();

        // Process each model's fields to find reference fields
        foreach (var model in Document.Models)
        {
            foreach (var field in model.Fields)
            {
                // Skip if not a reference or target not specified
                if (!field.BaseField.IsReference || string.IsNullOrEmpty(field.BaseField.ReferenceTarget))
                    continue;

                string targetModelName = field.BaseField.ReferenceTarget;
                string sourceModelName = model.BaseModel.Name;
                string fieldName = field.BaseField.Name;

                // Add outgoing relationship (source -> target)
                // This is a to-one relationship from source to target
                string navigationPropertyName = GetNavigationPropertyName(targetModelName, fieldName);
                AddRelationship(relationMap, sourceModelName, targetModelName, navigationPropertyName, false, fieldName, true);

                // Add incoming relationship (target <- source)
                // This is a to-many relationship from target back to source
                string backrefPropertyName = GetBackReferencePropertyName(sourceModelName, fieldName);
                AddRelationship(relationMap, targetModelName, sourceModelName, backrefPropertyName, true);
            }
        }

        // Process explicit model relations
        foreach (var model in Document.Models)
        {
            foreach (var relation in model.BaseModel.Relations)
            {
                // Skip if target not specified
                if (string.IsNullOrEmpty(relation.Target))
                    continue;

                string sourceModelName = model.BaseModel.Name;
                string targetModelName = relation.Target;
                string propertyName = relation.Name;

                // Find the foreign key field if it exists
                string foreignKeyField = null;
                if (!string.IsNullOrEmpty(relation.From))
                {
                    foreignKeyField = relation.From;
                }

                // Add the direct relationship 
                AddRelationship(relationMap, sourceModelName, targetModelName, propertyName, !relation.IsToOne, foreignKeyField);

                // For to-one relationships, add the reverse navigation property if not already defined
                if (relation.IsToOne)
                {
                    string backrefPropertyName = GetCollectionPropertyName(sourceModelName);
                    AddRelationship(relationMap, targetModelName, sourceModelName, backrefPropertyName, true);
                }
            }
        }

        return relationMap;
    }

    /// <summary>
    /// Add a relationship to the relationship map
    /// </summary>
    private void AddRelationship(
        Dictionary<string, List<RelationInfo>> relationMap,
        string sourceModel,
        string targetModel,
        string propertyName,
        bool isToMany,
        string navigationField = null,
        bool isForeignKey = false)
    {
        // Initialize list if needed
        if (!relationMap.ContainsKey(sourceModel))
        {
            relationMap[sourceModel] = new List<RelationInfo>();
        }

        // Check if relationship already exists
        var existingRelation = relationMap[sourceModel]
            .FirstOrDefault(r => r.TargetModel == targetModel && r.PropertyName == propertyName);

        if (existingRelation == null)
        {
            // Add the new relationship
            relationMap[sourceModel].Add(new RelationInfo
            {
                SourceModel = sourceModel,
                TargetModel = targetModel,
                PropertyName = propertyName,
                IsToMany = isToMany,
                NavigationField = navigationField,
                IsForeignKey = isForeignKey
            });
        }
        else if (!string.IsNullOrEmpty(navigationField))
        {
            // Update the existing relation with navigation field info if provided
            existingRelation.NavigationField = navigationField;
            existingRelation.IsForeignKey = isForeignKey;
        }
    }

    /// <summary>
    /// Get property name for a back-reference (collection)
    /// </summary>
    private string GetCollectionPropertyName(string modelName)
    {
        // Pluralize the model name for collections
        return $"{modelName}s";
    }

    /// <summary>
    /// Get property name for a back-reference based on field name
    /// </summary>
    private string GetBackReferencePropertyName(string modelName, string fieldName)
    {
        // If the field name already contains the model name, use plural form of the field
        if (fieldName.Contains(modelName, StringComparison.OrdinalIgnoreCase))
        {
            return $"{fieldName}s";
        }

        // Otherwise use the model name pluralized
        return GetCollectionPropertyName(modelName);
    }

    /// <summary>
    /// Get navigation property name based on the foreign key field name
    /// </summary>
    private string GetNavigationPropertyName(string targetModelName, string fieldName)
    {
        // If field name ends with _id, remove that suffix
        if (fieldName.EndsWith("_id", StringComparison.OrdinalIgnoreCase))
        {
            string baseName = fieldName.Substring(0, fieldName.Length - 3);
            // If the base name is just the target model name, return target model name
            if (string.Equals(baseName, targetModelName, StringComparison.OrdinalIgnoreCase))
            {
                return targetModelName;
            }
            return baseName;
        }

        // If field name contains the target model name, use that as the property name
        if (fieldName.Contains(targetModelName, StringComparison.OrdinalIgnoreCase))
        {
            // Extract just the target model part
            int idx = fieldName.IndexOf(targetModelName, StringComparison.OrdinalIgnoreCase);
            if (idx == 0)
            {
                return targetModelName;
            }

            // For things like UserId -> User
            if (fieldName.EndsWith("Id", StringComparison.OrdinalIgnoreCase))
            {
                return fieldName.Substring(0, fieldName.Length - 2);
            }
        }

        // Default to the target model name
        return targetModelName;
    }

    /// <summary>
    /// Get the namespace for a model
    /// </summary>
    private string GetNamespace(MDDModel model)
    {
        string baseNamespace = string.IsNullOrEmpty(_config.Namespace)
            ? Document.BaseDocument.Namespace
            : _config.Namespace;

        // For paths ending with underscore, use "Entity" as the namespace component (without the underscore)
        if (_config.ModelsPath.EndsWith("_"))
        {
            string folder = "Entity";
            return $"{baseNamespace}.{folder}";
        }

        // For regular paths, include the folder name as-is
        string folderName = Path.GetFileName(_config.ModelsPath);
        return $"{baseNamespace}.{folderName}";
    }

    /// <summary>
    /// Get the namespace for an interface
    /// </summary>
    private string GetNamespace(MDDInterface iface)
    {
        string baseNamespace = string.IsNullOrEmpty(_config.Namespace)
            ? Document.BaseDocument.Namespace
            : _config.Namespace;

        // For paths ending with underscore, use the path without underscore as namespace component
        if (_config.InterfacesPath.EndsWith("_"))
        {
            string folder = "Models";
            return $"{baseNamespace}.{folder}";
        }

        // For regular paths, include the folder name as-is
        string folderName = Path.GetFileName(_config.InterfacesPath);
        return $"{baseNamespace}.{folderName}";
    }

    /// <summary>
    /// Get the namespace for an enum
    /// </summary>
    private string GetNamespace(MDDEnum enum_)
    {
        string baseNamespace = string.IsNullOrEmpty(_config.Namespace)
            ? Document.BaseDocument.Namespace
            : _config.Namespace;

        // For paths ending with underscore, use the path without underscore as namespace component
        if (_config.EnumsPath.EndsWith("_"))
        {
            string folder = "Models";
            return $"{baseNamespace}.{folder}";
        }

        // For regular paths, include the folder name as-is
        string folderName = Path.GetFileName(_config.EnumsPath);
        return $"{baseNamespace}.{folderName}";
    }
}